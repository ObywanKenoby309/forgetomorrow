// ============================================================================
//  PRISMA CONFIGURATION
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
//  ENUMS
// ============================================================================

enum UserRole {
  SEEKER
  COACH
  RECRUITER
  ADMIN
}

enum Tier {
  FREE
  PRO
  COACH
  SMALL_BIZ
  ENTERPRISE
}

enum ContactRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum ProfileVisibility {
  PRIVATE
  PUBLIC
  RECRUITERS_ONLY
}

// ============================================================================
//  JOBS, APPLICATIONS, INTERVIEWS & OFFERS
// ============================================================================

model Job {
  id                Int      @id @default(autoincrement())
  company           String
  title             String
  worksite          String
  location          String
  type              String?
  compensation      String?
  description       String

  // These exist in the DB already ‚Äî keep them to avoid data loss
  salary            String?
  source            String?
  tags              String?
  url               String?

  status            String   @default("Draft")
  urgent            Boolean  @default(false)
  viewsCount        Int      @default(0)
  applicationsCount Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Owner
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // üî∏ which account / org owns this job (for tracing & reporting)
  accountKey String? // e.g. "ACCT-12345" or internal org code

  applications Application[]
  views        JobView[]
  interviews   Interview[]
  offers       Offer[]
  pinnedBy     PinnedJob[]
  covers       Cover[]

  @@index([accountKey])
  @@map("jobs")
}

enum ApplicationStatus {
  Applied
  Interviewing
  Offers
  ClosedOut
}

model Application {
  id Int @id @default(autoincrement())
  userId String
  jobId Int?
  resumeId Int?
  coverId Int?
  title String?
  company String?
  location String?
  status ApplicationStatus @default(Applied)
  appliedAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  job Job? @relation(fields: [jobId], references: [id])
  @@map("applications")
}

model JobView {
  id       Int      @id @default(autoincrement())
  userId   String
  jobId    Int
  viewedBy String?
  viewedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("job_views")
}

model Interview {
  id          Int      @id @default(autoincrement())
  userId      String
  jobId       Int
  scheduledAt DateTime
  status      String   @default("Scheduled")

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("interviews")
}

model Offer {
  id         Int      @id @default(autoincrement())
  userId     String
  jobId      Int
  salary     String?
  accepted   Boolean?
  receivedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("offers")
}

model PinnedJob {
  id Int @id @default(autoincrement())
  userId String
  jobId Int?
  title String?
  company String?
  location String?
  url String?
  pinnedAt DateTime @default(now())
  user User @relation(fields: [userId], references: [id])
  job Job? @relation(fields: [jobId], references: [id])
  @@map("pinned_jobs")
}

// ============================================================================
//  EXTERNAL / INGESTED JOB FEED (for cron imports)
// ============================================================================

model ExternalJob {
  id          String    @id @default(cuid())
  title       String?
  company     String?   @default("Not Provided")
  location    String?   @default("Not Provided")
  url         String?   @default("Not Provided")
  description String?
  salary      String?
  tags        String?
  publishedAt DateTime? @default(now())
  source      String
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt

  @@index([source])
  @@map("external_jobs")
}

// ============================================================================
//  RESUMES, COVERS, AND SCAN LOGS
// ============================================================================

model Resume {
  id        Int      @id @default(autoincrement())
  userId    String
  name      String
  content   String
  isPublic  Boolean  @default(false)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("resumes")
}

model Cover {
  id        Int      @id @default(autoincrement())
  userId    String
  jobId     Int?
  name      String
  content   String
  isPublic  Boolean  @default(false)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
  job  Job? @relation(fields: [jobId], references: [id])

  @@index([userId])
  @@index([jobId])
  @@map("covers")
}

model ScanLog {
  id        String   @id @default(cuid())
  userId    String
  date      String
  score     Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, date])
  @@map("scan_logs")
}

// ============================================================================
//  USER DRAFT CACHE (DB-backed replacement for localStorage)
// ============================================================================

model UserDraft {
  id        String   @id @default(cuid())
  userId    String
  key       String
  content   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key], name: "userId_key")
  @@index([userId])
  @@map("user_drafts")
}

// ============================================================================
//  VERIFICATION / AUTH
// ============================================================================

model VerificationToken {
  id           Int      @id @default(autoincrement())
  token        String   @unique
  email        String
  firstName    String
  lastName     String
  passwordHash String
  plan         String?
  newsletter   Boolean  @default(false)
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@map("verification_tokens")
}

// ============================================================================
//  CAREER TOOLS & HISTORY
// ============================================================================

model CareerRoadmap {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("UserCareerRoadmaps", fields: [userId], references: [id], onDelete: Cascade)
  generatedAt DateTime @default(now())
  data        Json
  pdfUrl      String?
  isPro       Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model Negotiation {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserNegotiations", fields: [userId], references: [id], onDelete: Cascade)
  input     Json
  result    Json
  pdfUrl    String?
  createdAt DateTime @default(now())

  @@index([userId])
}

model ProfileSnapshot {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserProfileSnapshots", fields: [userId], references: [id], onDelete: Cascade)
  headline  String?
  bio       String?
  skills    String
  resumeId  String?
  createdAt DateTime @default(now())

  @@index([userId])
}

// ============================================================================
//  CONSENT LOGGING
// ============================================================================

model UserConsent {
  id          Int      @id @default(autoincrement())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  consentType String
  region      String?
  given       Boolean  @default(true)
  timestamp   DateTime @default(now())

  @@index([userId])
  @@index([userId, consentType])
  @@map("user_consents")
}

// ============================================================================
//  COACHING RELATIONSHIPS
// ============================================================================

model CoachingClient {
  id          String   @id @default(cuid())
  coachId     String
  clientId    String?
  name        String
  email       String?
  status      String   @default("Active")
  nextSession DateTime?
  lastContact DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  coach  User  @relation("CoachClientsCoach", fields: [coachId], references: [id], onDelete: Cascade)
  client User? @relation("CoachClientsClient", fields: [clientId], references: [id], onDelete: Cascade)

  sessions CoachingSession[] @relation("ClientSessions")

  @@index([coachId])
  @@index([clientId])
  @@map("coaching_clients")
}

model CoachingSession {
  id       String @id @default(cuid())
  coachId  String
  clientId String?

  coachingClientId String?
  coachingClient   CoachingClient? @relation("ClientSessions", fields: [coachingClientId], references: [id])

  startAt     DateTime
  durationMin Int      @default(60)

  type   String @default("Strategy")
  status String @default("Scheduled")

  followUpDueAt DateTime?
  followUpDone  Boolean  @default(false)

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  coach  User  @relation("CoachSessionsCoach", fields: [coachId], references: [id], onDelete: Cascade)
  client User? @relation("CoachSessionsClient", fields: [clientId], references: [id], onDelete: Cascade)

  @@index([coachId])
  @@index([clientId])
  @@index([startAt])
  @@index([coachingClientId])
  @@map("coaching_sessions")
}

// ============================================================================
//  COACHING CSAT (DB-backed replacement for localStorage coachCSAT_v1)
// ============================================================================

model CoachingCsatResponse {
  id           String   @id @default(cuid())

  coachId String
  coach   User @relation("UserCoachingCsatResponses", fields: [coachId], references: [id], onDelete: Cascade)

  satisfaction Int
  timeliness   Int
  quality      Int

  comment   String?
  anonymous Boolean @default(true)

  createdAt DateTime @default(now())

  @@index([coachId])
  @@index([createdAt])
  @@map("coaching_csat_responses")
}

// ============================================================================
//  HEARTH SPOTLIGHTS ‚Äî COACH-MANAGED PUBLIC MENTOR CARD (DB-backed)
// ============================================================================

model HearthSpotlight {
  id           String   @id @default(cuid())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  name         String
  headline     String
  summary      String
  specialties  Json     // string[]
  rate         String   @default("Free")
  availability String   @default("Open to discuss")

  // Optional: keep for now (you said you may remove visible email later)
  contactEmail String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // One spotlight per coach (this is the ‚Äúlock it down‚Äù rule)
  @@unique([userId])

  @@index([createdAt])
  @@map("hearth_spotlights")
}

// ============================================================================
//  CONTACTS / NETWORK
// ============================================================================

model Contact {
  id            String   @id @default(cuid())
  userId        String
  contactUserId String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user        User @relation("UserContacts", fields: [userId], references: [id], onDelete: Cascade)
  contactUser User @relation("UserContactsAsContact", fields: [contactUserId], references: [id], onDelete: Cascade)

  @@unique([userId, contactUserId])
  @@index([userId])
  @@index([contactUserId])
  @@map("contacts")
}

model ContactRequest {
  id         String               @id @default(cuid())
  fromUserId String
  toUserId   String
  status     ContactRequestStatus @default(PENDING)
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt

  fromUser User @relation("UserContactRequestsFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("UserContactRequestsTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@index([fromUserId])
  @@index([toUserId])
  @@map("contact_requests")
}

// ============================================================================
//  USER ‚Äî FULL ACCOUNT + PROFILE
// ============================================================================

model User {
  id                         String  @id @default(cuid())
  email                      String  @unique
  emailVerified              Boolean @default(false)
  emailVerificationToken     String? @unique
  emailVerificationExpiresAt DateTime?
  passwordHash               String?
  firstName                  String?
  lastName                   String?
  name                       String?
  image                      String?

  headline  String?
  pronouns  String?
  location  String?
  status    String?
  avatarUrl String?
  coverUrl  String?

  bannerMode        String?
  bannerHeight      Int?
  bannerFocalY      Int?
  isProfilePublic   Boolean           @default(false)
  profileVisibility ProfileVisibility @default(PRIVATE)
  wallpaperUrl      String?

  slug              String?   @unique
  slugChangeCount   Int       @default(0)
  slugLastChangedAt DateTime?

  aboutMe         String?
  workPreferences Json?
  skillsJson      Json?
  languagesJson   Json?
  educationJson   Json?
  hobbiesJson     Json?

  role                 UserRole @default(SEEKER)
  plan                 Tier     @default(FREE)
  newsletter           Boolean  @default(false)
  mfaEnabled           Boolean  @default(false)
  mfaSecret            String?
  stripeCustomerId     String?  @unique
  stripeSubscriptionId String?  @unique

  accountKey String?

  applications Application[]
  views        JobView[]
  interviews   Interview[]
  offers       Offer[]
  pinnedJobs   PinnedJob[]
  resumes      Resume[]
  covers       Cover[]
  jobs         Job[]
  scanLogs     ScanLog[]

  drafts UserDraft[]

  careerRoadmaps   CareerRoadmap[]   @relation("UserCareerRoadmaps")
  negotiations     Negotiation[]     @relation("UserNegotiations")
  profileSnapshots ProfileSnapshot[] @relation("UserProfileSnapshots")
  consents         UserConsent[]

  candidates           Candidate[]
  candidateAutomations RecruiterCandidateAutomation[]

  messages                 Message[]                 @relation("UserMessages")
  conversationParticipants ConversationParticipant[] @relation("UserConversationParticipants")
  blocksInitiated          UserBlock[]               @relation("UserBlocksAsBlocker")
  blocksReceived          UserBlock[]               @relation("UserBlocksAsBlocked")
  messageReactions         MessageReaction[]         @relation("UserMessageReactions")
  reportsFiled             ConversationReport[]      @relation("UserReportsAsReporter")
  reportsReceived          ConversationReport[]      @relation("UserReportsAsReported")

  coachingClientsAsCoach   CoachingClient[]  @relation("CoachClientsCoach")
  coachingClientsAsClient  CoachingClient[]  @relation("CoachClientsClient")
  coachingSessionsAsCoach  CoachingSession[] @relation("CoachSessionsCoach")
  coachingSessionsAsClient CoachingSession[] @relation("CoachSessionsClient")

  coachingCsatResponses CoachingCsatResponse[] @relation("UserCoachingCsatResponses")

  hearthSpotlights HearthSpotlight[]

  contacts                Contact[]        @relation("UserContacts")
  contactsAsContact       Contact[]        @relation("UserContactsAsContact")
  contactRequestsSent     ContactRequest[] @relation("UserContactRequestsFrom")
  contactRequestsReceived ContactRequest[] @relation("UserContactRequestsTo")

  groupMemberships        GroupMembership[]
  ownedGroups             Group[]
  ownedPages              Page[]
  pageFollows             PageFollower[]
  ownedNewsletters        Newsletter[]
  newsletterSubscriptions NewsletterSubscription[]

  recruiterCalendarOwnedItems  RecruiterCalendarItem[] @relation("UserRecruiterCalendarOwner")
  recruiterCalendarAsCandidate RecruiterCalendarItem[] @relation("UserRecruiterCalendarCandidate")

  seekerCalendarItems SeekerCalendarItem[] @relation("UserSeekerCalendarItems")

  corporateBannerKey String?
  corporateBannerLocked Boolean @default(false)
  resumeAlignFreeUses Int @default(0)
  resumeAlignLastResetMonth String? // format "2025-12"
  deletedAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@map("users")
}

// ============================================================================
//  CANDIDATES ‚Äî RECRUITER-FACING SNAPSHOT
// ============================================================================

model Candidate {
  id     Int    @id @default(autoincrement())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name         String
  email        String?
  headline     String?
  summary      String?
  location     String?
  role         String?
  title        String?
  currentTitle String?

  workStatus        String?
  preferredWorkType String?
  willingToRelocate String?

  skills    String?
  languages String?

  tags          String?
  notes         String?
  source        String?
  pipelineStage String?

  match Int?

  lastContacted DateTime?
  lastSeen      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("candidates")
}

// ============================================================================
//  RECRUITER CANDIDATE AUTOMATION
// ============================================================================

model RecruiterCandidateAutomation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name    String?
  filters Json

  enabled   Boolean   @default(true)
  lastRunAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("recruiter_candidate_automation")
}

// ============================================================================
//  RECRUITER CALENDAR ITEMS
// ============================================================================

model RecruiterCalendarItem {
  id String @id @default(cuid())

  ownerId String
  owner   User @relation("UserRecruiterCalendarOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  scope String @default("team")

  date DateTime
  time String?

  title  String
  type   String @default("Interview")
  status String @default("Scheduled")
  notes  String?

  candidateType   String  @default("external")
  candidateUserId String?
  candidate       User?   @relation("UserRecruiterCalendarCandidate", fields: [candidateUserId], references: [id], onDelete: SetNull)
  candidateName   String

  company  String?
  jobTitle String?
  req      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([date])
  @@index([scope])
  @@map("recruiter_calendar_items")
}

// ============================================================================
//  SEEKER CALENDAR ITEMS
// ============================================================================

model SeekerCalendarItem {
  id String @id @default(cuid())

  userId String
  user   User @relation("UserSeekerCalendarItems", fields: [userId], references: [id], onDelete: Cascade)

  date DateTime
  time String?

  title  String
  type   String @default("Interview")
  status String @default("Scheduled")
  notes  String?

  source       String @default("personal")
  sourceItemId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([date])
  @@index([source])
  @@map("seeker_calendar_items")
}

// ============================================================================
//  MESSAGING ‚Äî CONVERSATIONS, MESSAGES, BLOCKS, REACTIONS, REPORTS
// ============================================================================

model Conversation {
  id      Int     @id @default(autoincrement())
  isGroup Boolean @default(false)
  title   String?
  channel String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  messages     Message[]
  participants ConversationParticipant[]
  reports      ConversationReport[]

  @@index([channel])
  @@index([createdAt])
  @@map("conversations")
}

model ConversationParticipant {
  id             Int      @id @default(autoincrement())
  conversationId Int
  userId         String
  joinedAt       DateTime @default(now())
  role           String?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation("UserConversationParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             Int      @id @default(autoincrement())
  conversationId Int
  senderId       String
  content        String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("UserMessages", fields: [senderId], references: [id])
  reactions    MessageReaction[]
  reports      ConversationReport[]

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("messages")
}

model UserBlock {
  id Int @id @default(autoincrement())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())
  
  // ‚úÖ NEW: Optional reason for block (from prompt in PostCard)
  reason String?

  blocker User @relation("UserBlocksAsBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlocksAsBlocked", fields: [blockedId], references: [id], onDelete: Cascade)
  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("user_blocks")
}

model MessageReaction {
  id        Int      @id @default(autoincrement())
  messageId Int
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("UserMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([userId])
  @@map("message_reactions")
}

model ConversationReport {
  id             Int      @id @default(autoincrement())
  conversationId Int
  reporterId     String
  reportedUserId String?
  messageId      Int?
  reason         String
  details        String?
  status         String   @default("OPEN")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  reporter     User         @relation("UserReportsAsReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser User?        @relation("UserReportsAsReported", fields: [reportedUserId], references: [id], onDelete: Cascade)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([conversationId])
  @@index([reporterId])
  @@index([reportedUserId])
  @@index([messageId])
  @@map("conversation_reports")
}

// ============================================================================
//  SOCIAL OBJECTS ‚Äî GROUPS, PAGES, NEWSLETTERS
// ============================================================================

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  isPrivate   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  memberships GroupMembership[]

  @@index([ownerId])
  @@map("groups")
}

model GroupMembership {
  id       String   @id @default(cuid())
  groupId  String
  userId   String
  role     String?
  joinedAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId])
  @@map("group_memberships")
}

model Page {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  website     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner     User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  followers PageFollower[]

  @@index([ownerId])
  @@map("pages")
}

model PageFollower {
  id         String   @id @default(cuid())
  pageId     String
  userId     String
  followedAt DateTime @default(now())

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pageId, userId])
  @@index([userId])
  @@map("page_followers")
}

model Newsletter {
  id          String   @id @default(cuid())
  title       String
  description String?
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner         User                     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  subscriptions NewsletterSubscription[]

  @@index([ownerId])
  @@map("newsletters")
}

model NewsletterSubscription {
  id             String    @id @default(cuid())
  newsletterId   String
  userId         String
  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?

  newsletter Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([newsletterId, userId])
  @@index([userId])
  @@map("newsletter_subscriptions")
}

// ============================================================================
//  COMMUNITY FEED
// ============================================================================

model FeedPost {
  id         Int      @id @default(autoincrement())
  authorId   String
  authorName String
  content    String
  type       String   @default("business")
  likes      Int      @default(0)
  comments   Json     @default("[]")
  reactions  Json?    @default("[]")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([authorId])
  @@map("feed_posts")
}

// ============================================================================
//  SUPPORT TICKETS
// ============================================================================

model SupportTicket {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String?
  userEmail String?

  subject        String
  initialMessage String

  source    String
  personaId String?
  intent    String?

  status String
}

// ============================================================================
//  PROFILE VIEWS ‚Äî WHO'S LOOKING AT YOU
// ============================================================================

model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String?
  targetId  String
  source    String?
  createdAt DateTime @default(now())

  @@index([targetId])
  @@index([viewerId])
  @@map("profile_views")
}
