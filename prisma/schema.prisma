// ============================================================================
//  PRISMA CONFIGURATION
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
//  ENUMS
// ============================================================================

enum UserRole {
  SEEKER
  COACH
  RECRUITER
  ADMIN
}

enum Tier {
  FREE
  PRO
  COACH
  SMALL_BIZ
  ENTERPRISE
}

enum ContactRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum ProfileVisibility {
  PRIVATE
  PUBLIC
  RECRUITERS_ONLY
}

// ✅ NEW: internal ForgeTomorrow staff roles (separate axis from customer UserRole)
enum StaffRole {
  PLATFORM_ADMIN
  CSM
  SALES
  DEV
  CS
  UX
}

// ✅ NEW: internal ForgeTomorrow departments (for Employee/Department gate)
enum Department {
  EXEC
  ENGINEERING
  PRODUCT
  UX
  CX
  CS
  SALES
  MARKETING
  FINANCE
  LEGAL
  OPERATIONS
  SECURITY
}

// ✅ NEW: org lifecycle (optional but useful immediately)
enum OrganizationStatus {
  PILOT
  ACTIVE
  SUSPENDED
}

enum ApplicationQuestionType {
  TEXT
  TEXTAREA
  NUMBER
  BOOLEAN
  DATE
  SELECT
  MULTISELECT
}

// ============================================================================
//  JOBS, APPLICATIONS, INTERVIEWS & OFFERS
// ============================================================================

model Job {
  id           Int     @id @default(autoincrement())
  company      String
  title        String
  worksite     String
  location     String
  type         String?
  compensation String?
  description  String

  // These exist in the DB already — keep them to avoid data loss
  salary String?
  source String?
  tags   String?
  url    String?

  status            String   @default("Draft")
  urgent            Boolean  @default(false)
  viewsCount        Int      @default(0)
  applicationsCount Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // ✅ NEW — distinguishes jobs vs templates
  isTemplate Boolean @default(false)

  // ✅ NEW — required when isTemplate = true
  templateName String?

  // Owner
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // which account / org owns this job or template
  accountKey String?
  organization Organization? @relation("OrganizationJobs", fields: [accountKey], references: [accountKey])

  // ✅ NEW — recruiter-defined addl questions (job-scoped, single-page, max ~6 by UI gate)
  // Stored as Json to avoid schema churn; UI controls cap count.
  // Each item: { key, label, type, required, helpText?, options? }
  additionalQuestions Json?

  applications Application[]
  views        JobView[]
  interviews   Interview[]
  offers       Offer[]
  pinnedBy     PinnedJob[]
  covers       Cover[]

  @@index([accountKey])
  @@index([isTemplate])
  @@map("jobs")
}

enum ApplicationStatus {
  Applied
  Interviewing
  Offers
  ClosedOut
}

model Application {
  id        Int               @id @default(autoincrement())
  userId    String
  jobId     Int?
  resumeId  Int?
  coverId   Int?
  title     String?
  company   String?
  location  String?
  url       String?
  notes     String?
  status    ApplicationStatus @default(Applied)
  appliedAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  // org routing for recruiter views
  accountKey String?

  // template + submit state
  templateId  String?
  submittedAt DateTime?

  // ✅ NEW — baseline "Role expectations" answers (standard on every internal app)
  // Availability, relocation, salary expectation, work authorization, sponsorship, etc.
  expectations ApplicationExpectations?

  // relations (template steps / consent / optional self-id / additional questions answers)
  template ApplicationTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  answers  ApplicationAnswer[]
  consent  ApplicationConsent?
  selfId   ApplicationSelfId?

  user User @relation(fields: [userId], references: [id])
  job  Job? @relation(fields: [jobId], references: [id])

  // real relations so you can include resume/cover cleanly
  resume Resume? @relation(fields: [resumeId], references: [id])
  cover  Cover?  @relation(fields: [coverId], references: [id])

  @@unique([userId, jobId], name: "user_job_unique")
  @@index([accountKey])
  @@map("applications")
}

model ApplicationExpectations {
  id            String      @id @default(cuid())
  applicationId Int         @unique
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // Standard recruiter triage fields (baseline for all internal apps)
  availability     String? // e.g., "Immediately", "2 weeks", "After 3/15"
  startDate        DateTime?
  willingToRelocate String? // "Yes" | "No" | "Depends"
  expectedSalary   String? // keep string for flexibility ("$85k", "$70-90k", "Open")
  workAuthorization String? // e.g., "US Citizen", "Authorized", etc.
  needsSponsorship Boolean? @default(false)

  // Optional: shift/travel if you want to capture now without forcing it
  willingToTravel  String? // "0-10%", "25%", etc.
  notes            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
  @@map("application_expectations")
}

model ApplicationTemplate {
  id         String @id @default(cuid())
  accountKey String

  name     String  @default("Default Application")
  version  Int     @default(1)
  isActive Boolean @default(true)

  steps        ApplicationTemplateStep[]
  applications Application[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([accountKey])
  @@index([isActive])
  @@map("application_templates")
}

model ApplicationTemplateStep {
  id         String              @id @default(cuid())
  templateId String
  template   ApplicationTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  key   String
  title String
  order Int

  questions ApplicationTemplateQuestion[]

  @@unique([templateId, key])
  @@index([templateId, order])
  @@map("application_template_steps")
}

model ApplicationTemplateQuestion {
  id     String                  @id @default(cuid())
  stepId String
  step   ApplicationTemplateStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  key      String
  label    String
  helpText String?
  type     ApplicationQuestionType
  required Boolean @default(false)

  options Json?

  @@unique([stepId, key])
  @@index([stepId])
  @@map("application_template_questions")
}

model ApplicationAnswer {
  id            String      @id @default(cuid())
  applicationId Int
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  questionKey String
  value       Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([applicationId, questionKey])
  @@index([applicationId])
  @@map("application_answers")
}

model ApplicationConsent {
  id            String      @id @default(cuid())
  applicationId Int         @unique
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  termsAccepted        Boolean @default(false)
  emailUpdatesAccepted Boolean @default(false)
  consentTextVersion   String?

  signatureName String?
  signedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
  @@map("application_consents")
}

model ApplicationSelfId {
  id            String      @id @default(cuid())
  applicationId Int         @unique
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  genderIdentity   String?
  raceEthnicity    String?
  veteranStatus    String?
  disabilityStatus String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("application_self_id")
}

model JobView {
  id       Int      @id @default(autoincrement())
  userId   String
  jobId    Int
  viewedBy String?
  viewedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("job_views")
}

model Interview {
  id          Int      @id @default(autoincrement())
  userId      String
  jobId       Int
  scheduledAt DateTime
  status      String   @default("Scheduled")

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("interviews")
}

model Offer {
  id         Int      @id @default(autoincrement())
  userId     String
  jobId      Int
  salary     String?
  accepted   Boolean?
  receivedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  @@map("offers")
}

model PinnedJob {
  id       Int      @id @default(autoincrement())
  userId   String
  jobId    Int?
  title    String?
  company  String?
  location String?
  url      String?
  pinnedAt DateTime @default(now())
  user     User     @relation(fields: [userId], references: [id])
  job      Job?     @relation(fields: [jobId], references: [id])

  @@map("pinned_jobs")
}


// ============================================================================
//  EXTERNAL / INGESTED JOB FEED (for cron imports)
// ============================================================================

model ExternalJob {
  id          String    @id @default(cuid())
  title       String?
  company     String?   @default("Not Provided")
  location    String?   @default("Not Provided")
  url         String?   @default("Not Provided")
  description String?
  salary      String?
  tags        String?
  publishedAt DateTime? @default(now())
  source      String
  createdAt   DateTime? @default(now())
  updatedAt   DateTime? @updatedAt

  @@index([source])
  @@map("external_jobs")
}

// ============================================================================
//  RESUMES, COVERS, AND SCAN LOGS
// ============================================================================

model Resume {
  id        Int      @id @default(autoincrement())
  userId    String
  name      String
  content   String
  isPublic  Boolean  @default(false)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  applications Application[]

  @@index([userId])
  @@map("resumes")
}

model Cover {
  id        Int      @id @default(autoincrement())
  userId    String
  jobId     Int?
  name      String
  content   String
  isPublic  Boolean  @default(false)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
  job  Job? @relation(fields: [jobId], references: [id])

  applications Application[]

  @@index([userId])
  @@index([jobId])
  @@map("covers")
}

model ScanLog {
  id        String   @id @default(cuid())
  userId    String
  date      String
  score     Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@map("scan_logs")
}

// ============================================================================
//  USER DRAFT CACHE (DB-backed replacement for localStorage)
// ============================================================================

model UserDraft {
  id        String   @id @default(cuid())
  userId    String
  key       String
  content   Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key], name: "userId_key")
  @@index([userId])
  @@map("user_drafts")
}

// ============================================================================
//  VERIFICATION / AUTH
// ============================================================================

model VerificationToken {
  id           Int      @id @default(autoincrement())
  token        String   @unique
  email        String
  firstName    String
  lastName     String
  passwordHash String
  plan         String?
  newsletter   Boolean  @default(false)
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@map("verification_tokens")
}

// ✅ NEW: Password Reset Tokens (DB-backed, hashed-at-rest, single-use)
model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([createdAt])
  @@map("password_reset_tokens")
}

// ============================================================================
//  CAREER TOOLS & HISTORY
// ============================================================================

model CareerRoadmap {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("UserCareerRoadmaps", fields: [userId], references: [id], onDelete: Cascade)
  generatedAt DateTime @default(now())
  data        Json
  pdfUrl      String?
  isPro       Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model Negotiation {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserNegotiations", fields: [userId], references: [id], onDelete: Cascade)
  input     Json
  result    Json
  pdfUrl    String?
  createdAt DateTime @default(now())

  @@index([userId])
}

model ProfileSnapshot {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserProfileSnapshots", fields: [userId], references: [id], onDelete: Cascade)
  headline  String?
  bio       String?
  skills    String
  resumeId  String?
  createdAt DateTime @default(now())

  @@index([userId])
}

// ============================================================================
//  CONSENT LOGGING
// ============================================================================

model UserConsent {
  id          Int      @id @default(autoincrement())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  consentType String
  region      String?
  given       Boolean  @default(true)
  timestamp   DateTime @default(now())

  @@index([userId])
  @@index([userId, consentType])
  @@map("user_consents")
}

// ============================================================================
//  COACHING RELATIONSHIPS
// ============================================================================

model CoachingClient {
  id          String    @id @default(cuid())
  coachId     String
  clientId    String?
  name        String
  email       String?
  status      String    @default("Active")
  nextSession DateTime?
  lastContact DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  coach  User  @relation("CoachClientsCoach", fields: [coachId], references: [id], onDelete: Cascade)
  client User? @relation("CoachClientsClient", fields: [clientId], references: [id], onDelete: Cascade)

  sessions CoachingSession[] @relation("ClientSessions")

  @@index([coachId])
  @@index([clientId])
  @@map("coaching_clients")
}

model CoachingSession {
  id       String  @id @default(cuid())
  coachId  String
  clientId String?

  coachingClientId String?
  coachingClient   CoachingClient? @relation("ClientSessions", fields: [coachingClientId], references: [id])

  startAt     DateTime
  durationMin Int      @default(60)

  type   String @default("Strategy")
  status String @default("Scheduled")

  followUpDueAt DateTime?
  followUpDone  Boolean   @default(false)

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  coach  User  @relation("CoachSessionsCoach", fields: [coachId], references: [id], onDelete: Cascade)
  client User? @relation("CoachSessionsClient", fields: [clientId], references: [id], onDelete: Cascade)

  @@index([coachId])
  @@index([clientId])
  @@index([startAt])
  @@index([coachingClientId])
  @@map("coaching_sessions")
}

// ============================================================================
//  COACHING CSAT (DB-backed replacement for localStorage coachCSAT_v1)
// ============================================================================

model CoachingCsatResponse {
  id String @id @default(cuid())

  coachId String
  coach   User   @relation("UserCoachingCsatResponses", fields: [coachId], references: [id], onDelete: Cascade)

  satisfaction Int
  timeliness   Int
  quality      Int

  comment   String?
  anonymous Boolean @default(true)

  createdAt DateTime @default(now())

  @@index([coachId])
  @@index([createdAt])
  @@map("coaching_csat_responses")
}

// ============================================================================
//  HEARTH SPOTLIGHTS — COACH-MANAGED PUBLIC MENTOR CARD (DB-backed)
// ============================================================================

model HearthSpotlight {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name         String
  headline     String
  summary      String
  specialties  Json // string[]
  rate         String @default("Free")
  availability String @default("Open to discuss")

  // Optional: keep for now (you said you may remove visible email later)
  contactEmail String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // One spotlight per coach (this is the “lock it down” rule)
  @@unique([userId])
  @@index([createdAt])
  @@map("hearth_spotlights")
}

// ============================================================================
//  CONTACTS / NETWORK
// ============================================================================

model Contact {
  id            String   @id @default(cuid())
  userId        String
  contactUserId String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user        User @relation("UserContacts", fields: [userId], references: [id], onDelete: Cascade)
  contactUser User @relation("UserContactsAsContact", fields: [contactUserId], references: [id], onDelete: Cascade)

  @@unique([userId, contactUserId])
  @@index([userId])
  @@index([contactUserId])
  @@map("contacts")
}

model ContactRequest {
  id         String               @id @default(cuid())
  fromUserId String
  toUserId   String
  status     ContactRequestStatus @default(PENDING)
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt

  fromUser User @relation("UserContactRequestsFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("UserContactRequestsTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([fromUserId, toUserId])
  @@index([fromUserId])
  @@index([toUserId])
  @@map("contact_requests")
}

// ============================================================================
//  ORGANIZATIONS (Recruiter org ownership + future seats)
//  NOTE: links via existing accountKey on User/Job to avoid breaking existing data.
// ============================================================================

model Organization {
  id     String             @id @default(cuid())
  name   String
  status OrganizationStatus @default(PILOT)

  // ✅ The stable "join key" already used in User.accountKey / Job.accountKey
  accountKey String @unique

  // Customer org owner/superuser (optional now, but needed soon)
  ownerUserId String?
  owner       User?   @relation("OrganizationOwner", fields: [ownerUserId], references: [id], onDelete: SetNull)

  // ✅ Back-relations via accountKey (no extra columns required on User/Job)
  users User[] @relation("OrganizationUsers")
  jobs  Job[]  @relation("OrganizationJobs")

  // ✅ NEW: multi-org access
  members OrganizationMember[] @relation("OrganizationMembers")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerUserId])
  @@map("organizations")
}

model OrganizationMember {
  id String @id @default(cuid())

  // Org scoping via existing accountKey convention
  accountKey   String
  organization Organization @relation("OrganizationMembers", fields: [accountKey], references: [accountKey], onDelete: Cascade)

  // The user who has access to the org (recruiter, admin, staff, etc.)
  userId String
  user   User   @relation("UserOrganizationMembers", fields: [userId], references: [id], onDelete: Cascade)

  // Optional: role within THIS org (use later, doesn't break now)
  role String?

  createdAt DateTime @default(now())

  @@unique([accountKey, userId])
  @@index([accountKey])
  @@index([userId])
  @@map("organization_members")
}

// ============================================================================
//  INTERNAL STAFF ROLES (Option B) — many-to-many User ↔ StaffRole
// ============================================================================

model UserStaffRole {
  id        String    @id @default(cuid())
  userId    String
  role      StaffRole
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([role])
  @@index([userId])
  @@map("user_staff_roles")
}

// ============================================================================
//  AUDIT LOG (supports impersonation + admin actions)
// ============================================================================

model AuditLog {
  id String @id @default(cuid())

  actorUserId String
  actor       User   @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: Cascade)

  impersonatedUserId String?
  impersonatedUser   User?   @relation("AuditImpersonated", fields: [impersonatedUserId], references: [id], onDelete: SetNull)

  action    String
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([actorUserId])
  @@index([impersonatedUserId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================================================
//  USER — FULL ACCOUNT + PROFILE
// ============================================================================

model User {
  id                         String    @id @default(cuid())
  email                      String    @unique
  emailVerified              Boolean   @default(false)
  emailVerificationToken     String?   @unique
  emailVerificationExpiresAt DateTime?
  passwordHash               String?
  firstName                  String?
  lastName                   String?
  name                       String?
  image                      String?

  headline          String?
  pronouns          String?
  location          String?
  status            String?
  avatarUrl         String?
  coverUrl          String?
  bannerMode        String?
  bannerHeight      Int?
  bannerFocalY      Int?
  isProfilePublic   Boolean           @default(false)
  profileVisibility ProfileVisibility @default(PRIVATE)
  wallpaperUrl      String?

  slug              String?   @unique
  slugChangeCount   Int       @default(0)
  slugLastChangedAt DateTime?

  aboutMe         String?
  workPreferences Json?
  skillsJson      Json?
  languagesJson   Json?
  educationJson   Json?
  hobbiesJson     Json?

  role                 UserRole @default(SEEKER)
  plan                 Tier     @default(FREE)
  newsletter           Boolean  @default(false)
  mfaEnabled           Boolean  @default(false)
  mfaSecret            String?
  stripeCustomerId     String?  @unique
  stripeSubscriptionId String?  @unique

  accountKey String?

  employee   Boolean     @default(false)
  department Department?

  organization            Organization?        @relation("OrganizationUsers", fields: [accountKey], references: [accountKey])
  organizationMemberships OrganizationMember[] @relation("UserOrganizationMembers")
  staffRoles              UserStaffRole[]

  auditAsActor        AuditLog[] @relation("AuditActor")
  auditAsImpersonated AuditLog[] @relation("AuditImpersonated")

  ownedOrganizations Organization[] @relation("OrganizationOwner")

  profileViewsReceived ProfileView[] @relation("ProfileViewTarget")
  profileViewsMade     ProfileView[] @relation("ProfileViewViewer")

  feedPostViews FeedPostView[] @relation("UserFeedPostViews")

  applications Application[]
  views        JobView[]
  interviews   Interview[]
  offers       Offer[]
  pinnedJobs   PinnedJob[]
  resumes      Resume[]
  covers       Cover[]
  jobs         Job[]
  scanLogs     ScanLog[]

  drafts UserDraft[]

  careerRoadmaps   CareerRoadmap[]   @relation("UserCareerRoadmaps")
  negotiations     Negotiation[]     @relation("UserNegotiations")
  profileSnapshots ProfileSnapshot[] @relation("UserProfileSnapshots")
  consents         UserConsent[]

  candidates           Candidate[]
  candidateAutomations RecruiterCandidateAutomation[]

  // ✅ NEW: inverse relations for named explain run relations
  recruiterExplainRuns RecruiterExplainRun[] @relation("RecruiterExplainRunsAsRecruiter")
  candidateExplainRuns RecruiterExplainRun[] @relation("RecruiterExplainRunsAsCandidate")

  recruiterCandidatesOwned  RecruiterCandidate[] @relation("RecruiterCandidateRecruiter")
  recruiterCandidatesAsUser RecruiterCandidate[] @relation("RecruiterCandidateCandidate")

  messages                 Message[]                 @relation("UserMessages")
  conversationParticipants ConversationParticipant[] @relation("UserConversationParticipants")
  blocksInitiated          UserBlock[]               @relation("UserBlocksAsBlocker")
  blocksReceived           UserBlock[]               @relation("UserBlocksAsBlocked")
  messageReactions         MessageReaction[]         @relation("UserMessageReactions")
  reportsFiled             ConversationReport[]      @relation("UserReportsAsReporter")
  reportsReceived          ConversationReport[]      @relation("UserReportsAsReported")

  coachingClientsAsCoach   CoachingClient[]  @relation("CoachClientsCoach")
  coachingClientsAsClient  CoachingClient[]  @relation("CoachClientsClient")
  coachingSessionsAsCoach  CoachingSession[] @relation("CoachSessionsCoach")
  coachingSessionsAsClient CoachingSession[] @relation("CoachSessionsClient")

  coachingCsatResponses CoachingCsatResponse[] @relation("UserCoachingCsatResponses")
  hearthSpotlights      HearthSpotlight[]

  contacts                Contact[]        @relation("UserContacts")
  contactsAsContact       Contact[]        @relation("UserContactsAsContact")
  contactRequestsSent     ContactRequest[] @relation("UserContactRequestsFrom")
  contactRequestsReceived ContactRequest[] @relation("UserContactRequestsTo")

  groupMemberships        GroupMembership[]
  ownedGroups             Group[]
  ownedPages              Page[]
  pageFollows             PageFollower[]
  ownedNewsletters        Newsletter[]
  newsletterSubscriptions NewsletterSubscription[]

  recruiterCalendarOwnedItems  RecruiterCalendarItem[] @relation("UserRecruiterCalendarOwner")
  recruiterCalendarAsCandidate RecruiterCalendarItem[] @relation("UserRecruiterCalendarCandidate")

  seekerCalendarItems SeekerCalendarItem[] @relation("UserSeekerCalendarItems")

  passwordResetTokens PasswordResetToken[]

  corporateBannerKey        String?
  corporateBannerLocked     Boolean   @default(false)
  resumeAlignFreeUses       Int       @default(0)
  resumeAlignLastResetMonth String?
  deletedAt                 DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt

  @@map("users")
}

// ============================================================================
//  CANDIDATES — RECRUITER-FACING SNAPSHOT
// ============================================================================

model Candidate {
  id     Int    @id @default(autoincrement())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name         String
  email        String?
  headline     String?
  summary      String?
  location     String?
  role         String?
  title        String?
  currentTitle String?

  workStatus        String?
  preferredWorkType String?
  willingToRelocate String?

  skills    String?
  languages String?

  tags          String?
  notes         String?
  source        String?
  pipelineStage String?

  match Int?

  lastContacted DateTime?
  lastSeen      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("candidates")
}

// ============================================================================
//  RECRUITER CANDIDATE (Option A) — recruiter-specific metadata for a User
// ============================================================================

model RecruiterCandidate {
  id String @id @default(cuid())

  recruiterUserId String
  recruiter       User   @relation("RecruiterCandidateRecruiter", fields: [recruiterUserId], references: [id], onDelete: Cascade)

  candidateUserId String
  candidate       User   @relation("RecruiterCandidateCandidate", fields: [candidateUserId], references: [id], onDelete: Cascade)

  accountKey String

  tags          Json?
  skills        Json?
  notes         String?
  pipelineStage String?
  lastContacted DateTime?
  lastSeen      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([recruiterUserId, candidateUserId, accountKey])
  @@index([recruiterUserId])
  @@index([candidateUserId])
  @@index([accountKey])
  @@map("recruiter_candidates")
}

// ============================================================================
//  RECRUITER CANDIDATE AUTOMATION (KEEP ONLY THIS ONE)
// ============================================================================

model RecruiterCandidateAutomation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name    String?
  filters Json

  enabled   Boolean   @default(true)
  lastRunAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("recruiter_candidate_automation")
}

model RecruiterExplainRun {
  id String @id @default(cuid())

  recruiterUserId String
  recruiter       User   @relation("RecruiterExplainRunsAsRecruiter", fields: [recruiterUserId], references: [id], onDelete: Cascade)

  candidateUserId String?
  candidate       User?   @relation("RecruiterExplainRunsAsCandidate", fields: [candidateUserId], references: [id], onDelete: SetNull)

  jobId Int?

  resumeText     String
  jobDescription String

  result     Json
  accountKey String?

  createdAt DateTime @default(now())

  @@index([recruiterUserId])
  @@index([candidateUserId])
  @@index([jobId])
  @@index([accountKey])
  @@map("recruiter_explain_runs")
}

// ============================================================================
//  RECRUITER CALENDAR ITEMS
// ============================================================================

model RecruiterCalendarItem {
  id String @id @default(cuid())

  ownerId String
  owner   User   @relation("UserRecruiterCalendarOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  scope String @default("team")

  date DateTime
  time String?

  title  String
  type   String  @default("Interview")
  status String  @default("Scheduled")
  notes  String?

  candidateType   String  @default("external")
  candidateUserId String?
  candidate       User?   @relation("UserRecruiterCalendarCandidate", fields: [candidateUserId], references: [id], onDelete: SetNull)
  candidateName   String

  company   String?
  jobTitle  String?
  req       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([date])
  @@index([scope])
  @@map("recruiter_calendar_items")
}

// ============================================================================
//  SEEKER CALENDAR ITEMS
// ============================================================================

model SeekerCalendarItem {
  id String @id @default(cuid())

  userId String
  user   User   @relation("UserSeekerCalendarItems", fields: [userId], references: [id], onDelete: Cascade)

  date DateTime
  time String?

  title  String
  type   String  @default("Interview")
  status String  @default("Scheduled")
  notes  String?

  source       String  @default("personal")
  sourceItemId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([date])
  @@index([source])
  @@map("seeker_calendar_items")
}

// ============================================================================
//  MESSAGING — CONVERSATIONS, MESSAGES, BLOCKS, REACTIONS, REPORTS
// ============================================================================

model Conversation {
  id      Int     @id @default(autoincrement())
  isGroup Boolean @default(false)
  title   String?
  channel String?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  messages     Message[]
  participants ConversationParticipant[]
  reports      ConversationReport[]

  @@index([channel])
  @@index([createdAt])
  @@map("conversations")
}

model ConversationParticipant {
  id             Int      @id @default(autoincrement())
  conversationId Int
  userId         String
  joinedAt       DateTime @default(now())
  role           String?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation("UserConversationParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             Int      @id @default(autoincrement())
  conversationId Int
  senderId       String
  content        String
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  sender User @relation("UserMessages", fields: [senderId], references: [id])

  reactions MessageReaction[]
  reports   ConversationReport[]

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("messages")
}

model UserBlock {
  id        Int      @id @default(autoincrement())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  reason String?

  blocker User @relation("UserBlocksAsBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("UserBlocksAsBlocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("user_blocks")
}

model MessageReaction {
  id        Int      @id @default(autoincrement())
  messageId Int
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("UserMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([userId])
  @@map("message_reactions")
}

model ConversationReport {
  id             Int      @id @default(autoincrement())
  conversationId Int
  reporterId     String
  reportedUserId String?
  messageId      Int?
  reason         String
  details        String?
  status         String   @default("OPEN")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  reporter     User         @relation("UserReportsAsReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser User?        @relation("UserReportsAsReported", fields: [reportedUserId], references: [id], onDelete: Cascade)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([conversationId])
  @@index([reporterId])
  @@index([reportedUserId])
  @@index([messageId])
  @@map("conversation_reports")
}

// ============================================================================
//  SOCIAL OBJECTS — GROUPS, PAGES, NEWSLETTERS
// ============================================================================

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  isPrivate   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  memberships GroupMembership[]

  @@index([ownerId])
  @@map("groups")
}

model GroupMembership {
  id       String   @id @default(cuid())
  groupId  String
  userId   String
  role     String?
  joinedAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId])
  @@map("group_memberships")
}

model Page {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  website     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner     User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  followers PageFollower[]

  @@index([ownerId])
  @@map("pages")
}

model PageFollower {
  id         String   @id @default(cuid())
  pageId     String
  userId     String
  followedAt DateTime @default(now())

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pageId, userId])
  @@index([userId])
  @@map("page_followers")
}

model Newsletter {
  id          String   @id @default(cuid())
  title       String
  description String?
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner         User                     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  subscriptions NewsletterSubscription[]

  @@index([ownerId])
  @@map("newsletters")
}

model NewsletterSubscription {
  id             String    @id @default(cuid())
  newsletterId   String
  userId         String
  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?

  newsletter Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([newsletterId, userId])
  @@index([userId])
  @@map("newsletter_subscriptions")
}

// ============================================================================
//  COMMUNITY FEED
// ============================================================================

model FeedPost {
  id         Int      @id @default(autoincrement())
  authorId   String
  authorName String
  content    String
  type       String   @default("business")
  likes      Int      @default(0)
  comments   Json     @default("[]")
  reactions  Json?    @default("[]")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  views FeedPostView[]

  @@index([authorId])
  @@map("feed_posts")
}

model FeedPostView {
  id        Int      @id @default(autoincrement())
  postId    Int
  viewerId  String?
  source    String?  @default("feed")
  createdAt DateTime @default(now())

  post   FeedPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  viewer User?    @relation("UserFeedPostViews", fields: [viewerId], references: [id], onDelete: SetNull)

  @@index([postId, createdAt])
  @@index([viewerId, createdAt])
  @@map("feed_post_views")
}

// ============================================================================
//  SUPPORT TICKETS
// ============================================================================

model SupportTicket {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String?
  userEmail String?

  subject        String
  initialMessage String

  source    String
  personaId String?
  intent    String?

  status String

  @@map("support_tickets")
}

// ============================================================================
//  PROFILE VIEWS — WHO'S LOOKING AT YOU
// ============================================================================

model ProfileView {
  id        String   @id @default(cuid())
  viewerId  String?
  targetId  String
  source    String?
  createdAt DateTime @default(now())

  viewer User? @relation("ProfileViewViewer", fields: [viewerId], references: [id], onDelete: SetNull)
  target User  @relation("ProfileViewTarget", fields: [targetId], references: [id], onDelete: Cascade)

  @@index([targetId])
  @@index([viewerId])
  @@map("profile_views")
}
